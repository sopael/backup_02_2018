#include "ISRemoval.h"
#include <iostream>
#include <cmath>

#include <EVENT/LCCollection.h>
#include <IMPL/LCCollectionVec.h>
#include <EVENT/MCParticle.h>
#include <EVENT/ReconstructedParticle.h>
#include <UTIL/PIDHandler.h>
#include <UTIL/LCRelationNavigator.h>

// ----- include for verbosity dependend logging ---------
#include "marlin/VerbosityLevels.h"

#include <TFile.h>
#include <TLorentzVector.h>

using namespace lcio ;
using namespace marlin ;


ISRemoval aISRemoval ;

ISRemoval::ISRemoval() : Processor("ISRemoval") {

    // modify processor description
    _description = "ISRemoval does whatever it does ..." ;
    
    // register steering parameters: name, description, class-variable, default value
    registerInputCollection( LCIO::MCPARTICLE,
            "CollectionName" , 
            "Name of the MCParticle collection"  ,
            _colName ,
            std::string("MCParticle")
    );
    registerInputCollection(  LCIO::RECONSTRUCTEDPARTICLE,
            "recInPand" , 
            "Name of the input Pandora collection"  ,
            _colPandName ,
            std::string("SelectedPandoraPFANewPFOs")
    );

    registerOutputCollection( LCIO::RECONSTRUCTEDPARTICLE,
			     "recOutPandora" , 
			     "Name of the modified Pandora collection"  ,
			     _colOutName ,
			     std::string("ISRFreePandora")
			     );

    registerProcessorParameter( "CosConeAngle",
                                "Cosine of the half-angle of the cone used in isolation criteria",
                                _cosConeAngle,
                                float(0.98));

    registerProcessorParameter( "dRConeCut",
                                "dR(theta,phi) distance cut used in cone isolation criteria",
                                _dRConeCut,
                                float(0.5));

    registerProcessorParameter(	"isolCrit",
				"Isolation criteria used in cone pocedure: dR or cosTheta",
				_islCrt,
                                std::string("dR"));
    
    registerProcessorParameter( "coneERatioCut",
				"Egamma / Econe ratio cut used in cone isolation criteria",
                                _coneERatioCut,
                                float(0.9));



    registerOptionalParameter("OutputRootName",
			      "Name of the output root file",
			      _outFileName,
			      std::string("ISR_out.root")
			      );
    
}

void ISRemoval::init() { 

    streamlog_out(DEBUG) << "   init called  " << std::endl ;
   
  

    // usually a good idea to
    printParameters() ;
 
    _nRun = 0 ;
    _nEvt = 0 ;

    _dRConeCut = 3.0;//basicaly no cutting with value
    _coneERatioCut = 0.5;
    _dRConeE = _cosThetaConeE = _refE = -100.;
    _bDRIsolated = _bCosIsolated = false;

    _Tree = new TTree("IsrTr","A tree for 2 most energetic photons variables"); 

    _photPV = _photE1 = _photE2 = _photTh1 = _photTh2 = -100;
    _Tree->Branch("photE1",&_photE1,"photE1/F");
    _Tree->Branch("photE2",&_photE2,"photE2/F");
    _Tree->Branch("photTh1",&_photTh1,"photTh1/F");
    _Tree->Branch("photTh2",&_photTh2,"photTh2/F");

    _phot_genE1 = _phot_genE2 = _phot_genTh1 = _phot_genTh2 = -100;
    _Tree->Branch("phot_genE1",&_phot_genE1,"phot_genE1/F");
    _Tree->Branch("phot_genE2",&_phot_genE2,"phot_genE2/F");
    _Tree->Branch("phot_genTh1",&_phot_genTh1,"phot_genTh1/F");
    _Tree->Branch("phot_genTh2",&_phot_genTh2,"phot_genTh2/F");

    _Tree->Branch("dRConeE",&_dRConeE,"dRConeE/F");
    _Tree->Branch("cosThetaConeE",&_cosThetaConeE,"cosThetaConeE/F");
    _Tree->Branch("refE",&_refE,"refE/F");

    _Tree->Branch("bDRIsolated",&_bDRIsolated,"bDRIsolated/O");
    _Tree->Branch("bCosIsolated",&_bCosIsolated,"bCosIsolated/O");

}


void ISRemoval::processRunHeader( LCRunHeader* run) { 

    _nRun++ ;
} 



void ISRemoval::processEvent( LCEvent * evt ) { 


    // this gets called for every event 
    // usually the working horse ...

    // try to get lcio collection (exits if collection is not available)
    // NOTE: if the AIDAProcessor is activated in your steering file and Marlin is linked with
    //      RAIDA you may get the message: "*** Break *** segmentation violation" followed by a
    //      stack-trace (generated by ROOT) in case the collection is unavailable. This happens
    //      because ROOT is somehow catching the exit signal commonly used to exit a program
    //      intentionally. Sorry if this messsage may confuse you. Please ignore it!
    
  LCCollection* col = NULL;
  LCCollection* colPand = NULL;
  IMPL::LCCollectionVec* recVec = new IMPL::LCCollectionVec(  LCIO::RECONSTRUCTEDPARTICLE  ) ;
  recVec->setSubset(true);
  //recVec->setDefault(true);
  //LCCollectionVec* recData = new LCCollectionVec(  LCIO::RECONSTRUCTEDPARTICLE  ) ;
 


  try{
    col = evt->getCollection( _colName ) ;
  }
  catch( lcio::DataNotAvailableException e )
    {
      streamlog_out(WARNING) << _colName << " collection not available" << std::endl;
      col = NULL;
    }

  try{
    colPand = evt->getCollection( _colPandName ) ;
    _pfoCol = colPand;
  }
  catch( lcio::DataNotAvailableException e )
    {
      streamlog_out(WARNING) << _colPandName << " collection not available" << std::endl;
      col = NULL;
    }

  _photPV = -1;
  _photE1 = _photE2 = -1;
  _photTh1 = _photTh2 = -1;
  _phot_genE1 = _phot_genE2 = -1;
  _phot_genTh1 = _phot_genTh2 = -1;

  if( col != NULL && colPand != NULL ){

    int nMCP = col->getNumberOfElements()  ;
    int nEl =  colPand->getNumberOfElements();

    int ID1, ID2;
    ID1 = ID2 = -1;

    for(int pfo = 0 ; pfo < nEl ; ++pfo){
      
      ReconstructedParticle* panda = dynamic_cast<ReconstructedParticle*>( colPand->getElementAt( pfo ) );

      TLorentzVector P(panda->getMomentum(), panda->getEnergy());
      if( panda->getType() == 22 && panda->getClusters().size() == 0 ){ 
	streamlog_out(DEBUG) << " no cluster for photon!!! event: "<<_nEvt << std::endl ;
	streamlog_out(DEBUG) << " #part tracks intTheta: "<<  panda->getTracks().size() <<  std::endl ;	
 	streamlog_out(DEBUG) << " #part paricles intTheta: "<<  panda->getParticles().size() <<  std::endl ;	
      }

      if( panda->getType() == 22 && panda->getClusters().size() > 0 ){
	if( panda->getEnergy() > _photE1 ){ ID1 = pfo; _photE1 = panda->getEnergy(); _photTh1 = 180. / M_PI * P.Theta(); }
	else
	  if( panda->getEnergy() > _photE2 ){ ID2 = pfo; _photE2 = panda->getEnergy(); _photTh2 = 180. / M_PI * P.Theta(); }
      }
    }//end of loop over RecPart

    //copying the pandora collection without photons.. if those turn out to be isolated
    for(int pfo = 0 ; pfo < nEl ; ++pfo){
      bool bIsolated = false;
      ReconstructedParticle* panda = dynamic_cast<ReconstructedParticle*>( colPand->getElementAt( pfo ) );
      if(pfo == ID1 || pfo == ID2)
       	if( isIsolatedCone( panda ) )
	  bIsolated = true;
      if(!bIsolated)
	recVec->addElement( panda ) ;	
    }
    if(ID1>0) isIsolatedCone( dynamic_cast<ReconstructedParticle*>( colPand->getElementAt( ID1 ) )  );//redoing stuff just to get Tree vars filled for the most energetic photon
    streamlog_out(DEBUG) << " Adding collection: " << _colOutName << std::endl;
    evt->addCollection( recVec, _colOutName ) ; 
    
    for(int i=0; i< nMCP ; i++){
      MCParticle* p = dynamic_cast<MCParticle*>( col->getElementAt( i ) ) ;
      if( abs(p->getPDG()) == 22 && p->getDaughters().size() == 0 && i< 16) {
	TLorentzVector v1;
	
	streamlog_out(DEBUG) << " ISR photon: pdg: " << p->getPDG() << " parents[0]: "<<( ( p->getParents() )[0])->getPDG() << " energy: "<< p->getEnergy() << std::endl ; 
	v1.SetPxPyPzE(( p->getMomentum() )[0],( p->getMomentum() )[1],( p->getMomentum() )[2],p->getEnergy());
	if( p->getEnergy() > _phot_genE1 ){ _phot_genE1 = p->getEnergy(); _phot_genTh1 = 180. / M_PI * v1.Theta(); }
	else
	  if( p->getEnergy() > _phot_genE2 ){ _phot_genE2 = p->getEnergy(); _phot_genTh2 = 180. / M_PI * v1.Theta(); }
	  
      }
      if( abs(p->getPDG()) == 21 && i< 16) {
	streamlog_out(DEBUG) << "ISR gluon: pdg: " << p->getPDG() << " parents[0]: "<<( ( p->getParents() )[0])->getPDG() << " energy: "<< p->getEnergy() << std::endl ; 
      }
      
    }
    
  
  }

  /*ISRData* isrData = new ISRData();
  addAllEnergies(isrData);
  isrData->addB(_bDRIsolated);
  isrData->addB(_bCosIsolated);
  recData->addElement(isrData);
  recData->setDefault( true ) ;
  evt->addCollection( recVec, _colOutData ) ;
  */
  _Tree->Fill();
  _nEvt ++ ;
}



void ISRemoval::check( LCEvent * evt ) { 
    // nothing to check here - could be used to fill checkplots in reconstruction processor
}


void ISRemoval::end(){ 

  TString name(_outFileName);
  TFile* fOutFile = new TFile(name,"RECREATE");
  fOutFile->cd();
  _Tree->Write();
  fOutFile->Close();
    //   std::cout << "ISRemoval::end()  " << name() 
    // 	    << " processed " << _nEvt << " events in " << _nRun << " runs "
    // 	    << std::endl ;

}

/////////////////////////////////////////

bool ISRemoval::isIsolatedCone( ReconstructedParticle* pfo){ 

  float dRConeE = 0;
  float cosThetaConeE = 0;
  float refE = -1;
  TLorentzVector P4(pfo->getMomentum(), pfo->getEnergy());
  
  int npfo = _pfoCol->getNumberOfElements();
  for ( int i = 0; i < npfo; i++ ) {

    ReconstructedParticle* pfo_i = dynamic_cast<ReconstructedParticle*>( _pfoCol->getElementAt(i) );

    // don't add itself to the cone energy
    if ( pfo == pfo_i ){ refE = pfo_i->getEnergy();streamlog_out(DEBUG) << "This is the most energetic photon with energy: "<< refE <<  std::endl ; continue; }

    TLorentzVector p4(pfo_i->getMomentum(), pfo_i->getEnergy());

    float dR = sqrt( (P4.Theta() - p4.Theta())*(P4.Theta() - p4.Theta()) + (P4.Phi() - p4.Phi())*(P4.Phi() - p4.Phi()) );
    float cosTheta = P4.Vect()*p4.Vect()/( P4.Vect().Mag() * p4.Vect().Mag() );

    //streamlog_out(DEBUG) << " dr: " << dR << " r: \t"<< dR*ratio <<" ang: " << ang << " r: \t"<< ang*ratio<<" its cos: "<< cos(ang) << " r: \t"<< cos(ang)*ratio<<" cosTheta:" << cosTheta << " r: \t"<< cosTheta*ratio<<std::endl ;  

    if(dR < _dRConeCut) 
      dRConeE += pfo_i->getEnergy(); 
    if(cosTheta < _cosConeAngle) 
      cosThetaConeE += pfo_i->getEnergy(); 
  }
  _dRConeE = dRConeE;
  _cosThetaConeE =  cosThetaConeE;
  _refE = refE;

  if( dRConeE/refE < _coneERatioCut ) _bDRIsolated = true; else _bDRIsolated = false; 
  if( cosThetaConeE/refE < _coneERatioCut ) _bCosIsolated =  true; else _bCosIsolated = false; 

  if(_islCrt == "dR")
    return _bDRIsolated;
  else
    if(_islCrt == "cosTheta")
      return _bCosIsolated;
    else{
      streamlog_out(WARNING) << "isIsolatedCone: criteria not found!! --> "<< _islCrt << std::endl;
      return false;
    }
}

/////////////////////////////////////////

bool ISRemoval::isIsolatedFromTrack( ReconstructedParticle* p){ 

  return false;

}
///////////////////////
/*void ISRemoval::addAllEnergies(ISRData* isrD){

  isrD->addE(_photE1);
  isrD->addE(_photE2);
  isrD->addE(_photTh1);
  isrD->addE(_photTh2);

 isrD->addE(_phot_genE1);
 isrD->addE(_phot_genE2);
 isrD->addE(_phot_genTh1);
 isrD->addE(_phot_genTh2);

 isrD->addE(_dRConeE);
 isrD->addE(_cosThetaConeE);
 isrD->addE(_refE);
}
*/
